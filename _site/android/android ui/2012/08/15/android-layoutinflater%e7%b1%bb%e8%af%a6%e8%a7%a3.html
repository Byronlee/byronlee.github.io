<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>#android#  LayoutInflater类详解</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Byronlee</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>#android#  LayoutInflater类详解</h2>
<p class="meta">15 Aug 2012</p>

<div class="post">
<p><span style="color: #ff0000;">在实际开发中LayoutInflater这个类还是非常有用的，它的作用类似于findViewById()。不同点是LayoutInflater是用来找res/layout/下的xml布局文件，并且实例化；而findViewById()是找xml布局文件下的具体widget控件(如 Button、TextView等)。</span><br />
具体作用：</p>

<p><span style="color: #ff0000;">1、对于一个没有被载入或者想要动态载入的界面，都需要使用LayoutInflater.inflate()来载入；</span></p>

<p><span style="color: #ff0000;">2、对于一个已经载入的界面，就可以使用Activiyt.findViewById()方法来获得其中的界面元素。</span></p>

<p>LayoutInflater 是一个抽象类，在文档中如下声明：</p>

<blockquote><p>public abstract class LayoutInflater extends Object</p></blockquote>

<p><span style="color: #ff0000;">获得 LayoutInflater 实例的三种方式：</span></p>

<blockquote><p>1. LayoutInflater inflater = getLayoutInflater(); //调用Activity的getLayoutInflater()<br />
2<span style="color: #ff0000;">. LayoutInflater localinflater = (LayoutInflater)context.getSystemService</span><br />
(Context.LAYOUT_INFLATER_SERVICE);<br />
3. LayoutInflater inflater = LayoutInflater.from(context);</p></blockquote>

<p>其实，这三种方式本质是相同的，从源码中可以看出：</p>

<p><span style="color: #ff0000;">getLayoutInflater()：</span></p>

<p><span style="color: #ff0000;">Activity 的 getLayoutInflater() 方法是调用 PhoneWindow 的getLayoutInflater()方法</span>，看一下该源代码：</p>

<blockquote><p>public PhoneWindow(Context context) {<br />
super(context);<br />
mLayoutInflater = LayoutInflater.from(context);<br />
}</p></blockquote>

<p><span style="color: #ff0000;">可以看出它其实是调用 LayoutInflater.from(context)。 而LayoutInflater.from(context)又有其他调用：</span></p>

<p>LayoutInflater.from(context)：</p>

<blockquote><p>public static LayoutInflater from(Context context) {<br />
LayoutInflater LayoutInflater =<br />
<span style="color: #ff0000;">(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br />
if (LayoutInflater == null) {<br />
throw new AssertionError("LayoutInflater not found.");<br />
}<br />
return LayoutInflater;<br />
}</p></blockquote>

<p><span style="color: #ff0000;">可以看出它其实调用 context.getSystemService()。</span></p>

<p>&nbsp;</p>

<p><span style="color: #ff0000;">结论：所以这三种方式最终本质是都是调用的Context.getSystemService()。</span></p>

<p>&nbsp;</p>

<p>inflate 方法<br />
通过 sdk 的 api 文档，可以知道该方法有以下几种过载形式，返回值均是 View 对象，如下：</p>

<blockquote><p>public View inflate (int resource, ViewGroup root)<br />
public View inflate (XmlPullParser parser, ViewGroup root)<br />
public View inflate (XmlPullParser parser, ViewGroup root, boolean attachToRoot)<br />
public View inflate (int resource, ViewGroup root, boolean attachToRoot)</p></blockquote>

<p>1：<br />
public View inflate (int resource, ViewGroup root)<br />
reSource：View的layout的ID<br />
root：如果为null，则将此View作为根,此时既可以应用此View中的其他控件了。<br />
如果!null, 则将默认的layout作为View的根。</p>

<p>2:<br />
public View inflate ( XmlPullParser parser, ViewGroup root)<br />
parser:你需要解析xml的解析接口<br />
root：如果null，则将此View作为根,此时既可以应用此View中的其他控件了。<br />
如果!null, 则将默认的layout作为View的根。</p>

<p>3:<br />
public View inflate ( XmlPullParser parser, ViewGroup root, boolean attachToRoot)<br />
parser:你需要解析View的xml的解析接口<br />
root：如果null，则将此View作为根,此时既可以应用此View中的其他控件了。<br />
如果!null, 则将默认的layout作为View的根。<br />
attachToRoot：<br />
ture：也就将此解析的xml作为View根<br />
fase：则为默认的xml，做为根视图View</p>

<p>4:<br />
public View inflate (int resource, ViewGroup root, boolean attachToRoot)<br />
resource：View的layout的ID<br />
root：如果null，则将此View作为根,此时既可以应用此View中的其他控件了。<br />
如果!null, 则将默认的layout作为View的根。<br />
attachToRoot：<br />
ture：也就将此解析的xml作为View根<br />
fase：则为默认的xml，做为根视图View</p>

<p>&nbsp;<br />
示意代码：</p>

<blockquote><p>
LayoutInflater inflater = (LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);<br />
View view = inflater.inflate(R.layout.custom, (ViewGroup)findViewById(R.id.test));<br />
//EditText editText = (EditText)findViewById(R.id.content);// error<br />
EditText editText = (EditText)view.findViewById(R.id.content);
</p></blockquote>

<p>同时在此讲讲让我去API中去理解这四个函数的原因吧！嘿嘿！你肯定又会多学一招！<br />
在Activity中：<br />
大家是否知道,在setContentView(new MySurfaceView(this))后，此Activity中声明的View控件，<br />
如：TextView 为什么引用不到layout布局文件中的控件ID呢！初一看能够应用到，但是为什么编译就报空指针呢！原因：在setContentView(new MySurfaceView(this))后，此时的View变为了根视图了，虽然能应用到TextView对应的ID,但是我在 MySurfaceView中根本就没有这个对象，所以就报空指针咯！解决办法：<br />
View view = LayoutInflater.from(this).inflate(R.layout.passover, null);注：每解析一次都会产生不同的对象<br />
然后你再引用没问题，使用自如了。</p>

<p>学习参考：http://lpqsun-126-com.iteye.com/blog/1158070</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
