---
layout: post
status: publish
published: true
title: Ruby单元测试简单入门  附加  demo
author: Byronlee
author_login: ginchenorlee
author_email: ginchenorlee@sina.com
wordpress_id: 309
wordpress_url: http://www.ginchenorlee.com/?p=309
date: !binary |-
  MjAxMi0xMC0xMiAxMTo0MTowNCArMDAwMA==
date_gmt: !binary |-
  MjAxMi0xMC0xMiAxMTo0MTowNCArMDAwMA==
categories:
- 经验分享
- Ruby
tags:
- ruby，unit_test
comments: []
---
<p>学习一段时间ruby了，但是对单元测试一直是蒙蒙龙龙的，不知到具体怎么用，只是听队友们说的大概意思和原理，今天在研究 ruby on rails 时，又碰到这样的问题，所有花了点时间来看了看，记录一遍学习：</p>
<p>所谓单元测试就是针对你写的代码 再写一个测试例子，来看看是否达到你预期的情况，先来上一个例子来demo 来明白：</p>
<p>建立 test.rb 文件，里面的代码：</p>
<pre class="brush: ruby; gutter: true">require &quot;test/unit&quot;
class TestSetupTeardown &lt; Test::Unit::TestCase

  def setup
    super
    puts &quot;setup&quot;
  end

  def test_1
    puts &quot;test_1&quot;
  end

  def test_2
    puts &quot;test_2&quot;
  end

  def teardown
    super
    puts &quot;teardown&quot;
  end
end</pre>
<p>然后再你的终端（linux)里 输入</p>
<pre class="brush: actionscript3; gutter: true">$  ruby test.rb</pre>
<p>然后你就会看到输出：</p>
<pre class="brush: bash; gutter: true">byronlee@byronlee:~/workspace/ruby$ ruby test-unit.rb
Run options: 

# Running tests:

setup
test_1
teardown
.setup
test_2
teardown
.

Finished tests in 0.001035s, 1932.8975 tests/s, 0.0000 assertions/s.

2 tests, 0 assertions, 0 failures, 0 errors, 0 skips
byronlee@byronlee:~/workspace/ruby$</pre>
<p>根据内容就清楚大概了吧，setup 与teardown每次测试前都运行一次，做一些说明</p>
<p>1）  方法命名的要求， 必须是实例方法，却方法名需要以test开头。</p>
<p>2）  对应setup和teardown，这两个方法共享的代码块，是过程，而不是结果。 尤其是对应setup，比如通过setup获取了某个值，并不所有的test方法都公用这个值（普通的值)，而是所有的代码块都运行一次setup，重新获取该值。这是初学者经常出现误解的地方。</p>
<p>上面是一个简单的例子，下面来看看"断言“：</p>
<p>Ruby 使用一种称为Test::Unit (或者test/unit ) 的测试框架来运行应用程序的测试， 她类似于在其他程序语言中见到的xUnit 框架， 并且实现四个主要的概念：</p>
<p>assertion 是评估表达式及测试结果是否与期望值相同的一行程序代码 。</p>
<p>例如 ， 你可能assert (声明，断言) 密码长度至少是6个字符， 若此断言不成立则表示测试失败。</p>
<p>test 是一种方法， 其名称以test 开始。 集合了许多相关的assertion， 每个assertion 测试应用程序的一小部分，例如 ，test_for_disallowed_passwords 可能包含验证并拒绝不良密码 （像是太短，含空格 或密码为 "password"等等）的assertion</p>
<p>test case （测试案例）类是Test::Unit::TestCase 的子类， 她包含一组被设计用来测试应用程序功能范围的测试方法。</p>
<p>test suite （测试案例组）是一组测试案例的集合 。 当运行test suite时， 她测试她所包含的每个测试用例， 你将不需要在Rails应用程序中使用她， 因为Rails 会处理所有测试案例的运行工作。</p>
<p>再来看一个例子：建一个实例类：BasicNumber.rb</p>
<pre class="brush: ruby; gutter: true">class BasicNumber
    def initialize ( number )
        @number = number
      end

    def add ( x )
        @number + x
      end
    def multiply ( x )
        @number * x

    end
 end</pre>
<p>建一个测试类：TestPost .rb</p>
<pre class="brush: actionscript3; gutter: true">require &quot;test/unit&quot;
require &#039;BasicNumber.rb&#039;
class TestPost &lt; Test::Unit::TestCase
    def test_add
      n = BasicNumber.new(10)
      assert_equal (14,n.add(4),&#039;This test about add is failure!&#039;)
    end

    def test_multiply
      n = BasicNumber.new(10)
      assert_equal (4,n.multiply(4),&#039;This test about multiply is failure!&#039;)
    end
  end</pre>
<p>运行这个测试类，</p>
<pre class="brush: actionscript3; gutter: true">$ ruby TestPost.rb</pre>
<p>就可以测试之前的代码了,这里面对就用到了断言 （assert 方法），即使你从未知道或听说过它，一看就知道它的用途了。</p>
<p>常用的assertion如下：</p>
<p>各assertion的最后一个参数message表示测试失败时显示的消息</p>
<p>assert(boolean, [msg])<br />
assert_equal (expected, actual, [msg])<br />
assert_not_equal (expected, actual, [msg])<br />
assert_match (pattern, string, [msg])<br />
assert_no_match (pattern, string, [msg])<br />
assert_nil (object, [msg])<br />
assert_not_nil (object, [msg])<br />
assert_instance_of (class, object, [])<br />
assert_kind_of (class, object, [])<br />
assert_ralse (Exception, ...) {block}<br />
assert_nothing_ralsed (Exception, ...) {block}</p>
<p>部分做解释：</p>
<p>若boolean为真则pass，否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert(boolean, message=&quot;&quot;)</pre>
<p>若expected == actual则pass,否则输出message:</p>
<pre>assert_equal(expected, actual, [msg])</pre>
<p>若expected != actual则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_not_equal(expected, actual, message=&quot;&quot;)</pre>
<p>若klass == object.class为真则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_instance_of(klass, object, message=&quot;&quot;)</pre>
<p>若object.nil?则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_nil(object, message=&quot;&quot;)</pre>
<p>若!object.nil?则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_not_nil(object, message=&quot;&quot;)</pre>
<p>若object.kind_of?(klass)为真则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_kind_of(klass, object, message=&quot;&quot;)</pre>
<p>若object.respond_to?(method)为真则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_respond_to(object, method, message=&quot;&quot;)</pre>
<p>若string =~ pattern为真则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_match(pattern, string, message=&quot;&quot;)</pre>
<p>若regexp !~ string为真则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_no_match(regexp, string, message=&quot;&quot;)</pre>
<p>若actual.equal?(expected) 为真则 pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_same(expected, actual, message=&quot;&quot;)</pre>
<p>若!actual.equal?(expected) 为真则 pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_not_same(expected, actual, message=&quot;&quot;)</pre>
<p>若object1.send(operator, object2) 为真则 pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_operator(object1, operator, object2, message=&quot;&quot;)</pre>
<p>执行块的内容引发异常, 若该异常属于expected_exception_klass类则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_raises(expected_exception_klass, message=&quot;&quot;) { ... }</pre>
<p>执行块的内容, 若没有发生throw则pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_nothing_thrown(message=&quot;&quot;) { ... }</pre>
<p>若(expected_float.to_f - actual_float.to_f).abs &lt;= delta.to_f 为真则 pass<br />
delta必须是正数。,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_in_delta(expected_float, actual_float, delta, message=&quot;&quot;)</pre>
<p>若send_array[0].__send__(send_array[1], *send_array[2..-1])为真则 pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_send(send_array, message=&quot;&quot;)</pre>
<p>若block的结果为真则 pass,否则输出message:</p>
<pre class="brush: actionscript3; gutter: true">assert_block(message=&quot;&quot;) { ... }</pre>
<p>大致介绍这么多，有人说 Test::Unit 还是 Rspec？ 呵呵，也不是很清楚，</p>
<p>最后说三点：</p>
<p><span style="color: #ff0000;">1）</span> 《Web开发敏捷之道》 ruby on rails --------162或 163 页 对rails 上的单元测试有详细的解释，你用过rail,就知道，rails 创建项目后，项目文件里面有一个 test 文件夹，里面全是写单元测试文件的， 我们的test目录里有文件夹：fixtures/；functional/；integration/；test_helper.rb；unit/。  按照惯例,Rails 把模型的测试叫做单元测试(unit test),把控制器的测试叫做功能测试(functional test) , 而 对 “ 横 跨 多 个 控 制 器 的 业 务 流 程 ” 进 行 的 测 试 则 被 称 为 集 成 测 试(integration test)。 跟多的请在网上搜此书的pdf 电子当查看。</p>
<p><span style="color: #ff0000;">2）</span> 看一偏 ruby-china 的帖子：</p>
<p><a href="http://ruby-china.org/topics/166">http://ruby-china.org/topics/166</a>     Test::Unit 还是 Rspec，</p>
<p>3） 就是要学习跟多的测试，ruby测试官网  :  <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/test/unit/rdoc/Test/Unit/AutoRunner.html">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/test/unit/rdoc/Test/Unit/AutoRunner.html</a></p>
